# 2019年06月17日
#### 什么是闭包,说一下你的理解
> 闭包是函数和声明该函数的词法环境的组合。

- 词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。
- 函数的调用结果是返回一个内部函数,内部函数保持着对内部私有属性的引用状态
- javaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。
- 使用闭包来模拟私有方法
- 使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式
- 性能方面
  - 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。
  - 在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。
  
#### es6特性
- let、const
- import、export导入模块、export导出模块
- class、extends、super
- 箭头函数
- template string （模板字符串）
- 解构赋值
- default 函数默认参数
- rest arguments （rest参数）使用...x(收集参数)
- 展开运算符  ...array
- 对象初始化简写 {a: a} --> {a}
- 字面量简写
- Object.assign()
  - ES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}
- Promise
- Generators 
```js
  // 生成器
  function *createIterator() {
      yield 1;
      yield 2;
      yield 3;
  }
```
 
- promise和async/await的区别
  - Async/await 是建立在 Promises上的，不能被使用在普通回调以及节点回调
  - Async/await 和 Promises 很像，不阻塞
  - Async/await 代码看起来像同步代码。
  - async/await的优势
    - 更简洁的代码
    - 对错误的处理,可以使用try/catch捕获


#### promise错误处理
- 一般会自行捕获 使用 reject() 抛出,在promise返回值使用.catch(err)进行处理
- 手动将制定值抛出错误
- 注册全局的addEventListener来监听unhandledrejection事件，即可捕获到未处理的Promise错误
- 注册全局的addEventListener来监听rejectionhandled事件，如果一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件

 
#### http缓存
- 数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。
- 浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如

  - <META HTTP-EQUIV="Pragma" CONTENT="no-store">

  - 含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存。
#### 从浏览器地址栏输入地址到页面呈现,中间的过程
  - [详情地址](https://blog.csdn.net/u012862311/article/details/78753232)


#### vue依赖收集
- 是在vue渲染后绑定了`getter/setter`成为响应的数据的时候,在`getter`中收集的依赖
- 存储在`Dep`这个类里面,帮助管理依赖,
- Array数组的依赖存储在`Observe`中,在触发数据变动的时候可以通过`this`来访问`Observe1`

#### vue实现的原理

#### 本地存储的方式
- cookie
- h5新增的 存储限制要大得多（至少5MB），并且信息不会被传输到服务器
- localStorage- 存储没有截止日期的数据
- sessionStorage  针对一个 session 来存储数据（当关闭浏览器标签页时数据会丢失）

#### vue生命周期
- create  
- mounted
- update
- destroyed

#### js数据类型
- undefined，
- null，
- boolean，
- string，
- number，
- object，
- symbol(es6)

- 基本类型
  - String 为字符串基本类型。
  - Number 为数值基本类型。
  - Boolean 为布尔基本类型。
  - Symbol 为字面量基本类型。
- 复杂
 - array
 - object

#### js数据的基本数据类型 保存在哪里
- 基本数据类型保存在栈内存当中
- 引用(复杂)数据类型保存在堆内存当中
   
## 水滴询问遇到的问题
#### vue的时候常用的指令`5个常用的`
- v-if v-else v-else-if
- v-for 
- v-show
- v-bind
- v-model
- v-on
- v-slot
- v-text
- v-html

#### v-show和v-if的区别
- show相当于设置了`display:none;`
- if则是没有渲染dom
- 如果一个元素需要进行频繁的操作显示隐藏,建议使用show

#### v-if和v-for的优先级
- for优先
#### 计算属性和方法的区别
- 计算属性是有缓存
- 方法时每次都调用

#### vuex
- vuex有几个重要的组成部分
- vuex的异步操作
- mutation可以写异步么。写了会怎么样
- action能写同步么
- vuex如何使用module用过么
  - 关于全局挂载和局部挂载
- vuex动态注册
  - store.registerModule
- 原理
  - vuex 的设计是将数据存在一个对象树的变量中，我们的应用（vue应用）从这个变量中取数据，然后供应用使用，当将当前页面关闭， vuex 中的变量会随着消失，重新打开页面的时候，需要重新生成。
- 使用场景
  - 处理多组件依赖于同一个数据，例如有柱状图和条形图两个组件都是展示的同一数据；
  - 一个组件的行为——改变数据——影响另一个组件的视图，其实也就是公用依赖的数据；


#### router
- router有几种模式
  - vue的router还是根据浏览器原生api封装的
1. 在地址中加入#以欺骗浏览器，地址的改变是由于正在进行页内导航
  - hash即浏览器url中#后面的内容，包含#。hash是URL中的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会加载相应位置的内容，不会重新加载页面。

  - 即#是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中，不包含#。
  - 每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。
  - 所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。

2. 使用H5的window.history功能，使用URL的Hash来模拟一个完整的URL
  - HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；
  - 由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入"mode: 'history'",这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。
  - 有时，history模式下也会出问题：
    - hash模式下：xxx.com/#/id=5 请求地址为 xxx.com,没有问题。
    - history模式下：xxx.com/id=5 请求地址为 xxx.com/id=5，如果后端没有对应的路由处理，就会返回404错误；

  - 为了应对这种情况，需要后台配置支持：
    - 在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
3. abstract模式
  - abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。
  - 根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）。


#### Object.assign()和 解构的区别
- 性能方面的问题
- 解构赋值性能方面问题--解构赋值在数据量很大的情况下是很慢的
 
#### ES5和ES6继承的区别
1. ES5先创建子类，在实例化父类并添加到子类this中
2. ES6先创建父类，在实例化子集中通过调用super方法访问父级后，在通过修改this实现继承