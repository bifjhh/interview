{"./":{"url":"./","title":"概述","keywords":"","body":"记录的目的 结束日期为---直至找到工作 在线预览地址点击查看 主要记录内容 参加面试的时间 面试时候被提问的问题 自己想到or网上找到的比较有学习性的内容 补充说明 如果有愿意一起总结面试经验的小伙伴,可以一起补充,相互学习和补充 GitHub地址 后续 如果我找到工作,也会新开一个关于记录工作中的一些问题和需要学习的点 希望有更多的小伙伴一起加入 需要开通权限的小伙伴可以发issues给我 也可以邮件929160004@163.com我你的GitHub账号 "},"history/2019-06-17.html":{"url":"history/2019-06-17.html","title":"2019-06-17","keywords":"","body":"2019年06月17日 什么是闭包,说一下你的理解 闭包是函数和声明该函数的词法环境的组合。 词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。 函数的调用结果是返回一个内部函数,内部函数保持着对内部私有属性的引用状态 javaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。 使用闭包来模拟私有方法 使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式 性能方面 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。 es6特性 let、const import、export导入模块、export导出模块 class、extends、super 箭头函数 template string （模板字符串） 解构赋值 default 函数默认参数 rest arguments （rest参数）使用...x(收集参数) 展开运算符 ...array 对象初始化简写 {a: a} --> {a} 字面量简写 Object.assign() ES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{} Promise Generators // 生成器 function *createIterator() { yield 1; yield 2; yield 3; } promise和async/await的区别 Async/await 是建立在 Promises上的，不能被使用在普通回调以及节点回调 Async/await 和 Promises 很像，不阻塞 Async/await 代码看起来像同步代码。 async/await的优势 更简洁的代码 对错误的处理,可以使用try/catch捕获 promise错误处理 一般会自行捕获 使用 reject() 抛出,在promise返回值使用.catch(err)进行处理 手动将制定值抛出错误 注册全局的addEventListener来监听unhandledrejection事件，即可捕获到未处理的Promise错误 注册全局的addEventListener来监听rejectionhandled事件，如果一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件 http缓存 数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。 浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如 含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存。 从浏览器地址栏输入地址到页面呈现,中间的过程 详情地址 vue依赖收集 是在vue渲染后绑定了getter/setter成为响应的数据的时候,在getter中收集的依赖 存储在Dep这个类里面,帮助管理依赖, Array数组的依赖存储在Observe中,在触发数据变动的时候可以通过this来访问Observe1 vue实现的原理 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情... 当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿 当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom 当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等 组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以 本地存储的方式 cookie h5新增的 存储限制要大得多（至少5MB），并且信息不会被传输到服务器 localStorage- 存储没有截止日期的数据 sessionStorage 针对一个 session 来存储数据（当关闭浏览器标签页时数据会丢失） vue生命周期 create mounted update destroyed js数据类型 undefined， null， boolean， string， number， object， symbol(es6) 基本类型 String 为字符串基本类型。 Number 为数值基本类型。 Boolean 为布尔基本类型。 Symbol 为字面量基本类型。 复杂 array object js数据的基本数据类型 保存在哪里 基本数据类型保存在栈内存当中 引用(复杂)数据类型保存在堆内存当中 水滴询问遇到的问题 vue的时候常用的指令5个常用的 v-if v-else v-else-if v-for v-show v-bind v-model v-on v-slot v-text v-html v-show和v-if的区别 show相当于设置了display:none; if则是没有渲染dom 如果一个元素需要进行频繁的操作显示隐藏,建议使用show v-if和v-for的优先级 for优先计算属性和方法的区别 计算属性是有缓存 方法时每次都调用 vuex vuex有几个重要的组成部分 vuex的异步操作 mutation可以写异步么。写了会怎么样 action能写同步么 vuex如何使用module用过么 关于全局挂载和局部挂载 vuex动态注册 store.registerModule 原理 vuex 的设计是将数据存在一个对象树的变量中，我们的应用（vue应用）从这个变量中取数据，然后供应用使用，当将当前页面关闭， vuex 中的变量会随着消失，重新打开页面的时候，需要重新生成。 使用场景 处理多组件依赖于同一个数据，例如有柱状图和条形图两个组件都是展示的同一数据； 一个组件的行为——改变数据——影响另一个组件的视图，其实也就是公用依赖的数据； router router有几种模式 vue的router还是根据浏览器原生api封装的 在地址中加入#以欺骗浏览器，地址的改变是由于正在进行页内导航 hash即浏览器url中#后面的内容，包含#。hash是URL中的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会加载相应位置的内容，不会重新加载页面。 即#是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中，不包含#。 每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。 所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。 使用H5的window.history功能，使用URL的Hash来模拟一个完整的URL HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面； 由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入\"mode: 'history'\",这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 有时，history模式下也会出问题： hash模式下：xxx.com/#/id=5 请求地址为 xxx.com,没有问题。 history模式下：xxx.com/id=5 请求地址为 xxx.com/id=5，如果后端没有对应的路由处理，就会返回404错误； 为了应对这种情况，需要后台配置支持： 在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 abstract模式 abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。 根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）。 Object.assign()和 解构的区别 性能方面的问题 解构赋值性能方面问题--解构赋值在数据量很大的情况下是很慢的 ES5和ES6继承的区别 ES5先创建子类，在实例化父类并添加到子类this中 ES6先创建父类，在实例化子集中通过调用super方法访问父级后，在通过修改this实现继承 "},"history/2019-06-18.html":{"url":"history/2019-06-18.html","title":"2019-06-18","keywords":"","body":"2019年06月18日 vue-element-admin UI结构布局 面包屑如何实现页面切换的 子路由如何嵌套的 vue生命周期 详细说明一下各个生命周期都做了些什么 create mounted update destroyed 描述一下vue的流程? vue的开始到结束,实现了哪些 vue的虚拟DMO机制 虚拟dom是如何获取的 虚拟dom的优势 虚拟dom是如何改变页面的 css新增属性 盒模型 BFC JavaScript事件 队列 node.js事件 队列机制 http缓存 描述本地存储方式,及区别 基础js操作DOM 获取样式 获取宽高 事件委托 算法基础类 冒泡排序,快速排序 js 原型链 原型链是如何连接到上层的 js 继承 es5的继承是怎么实现的 es6的继承是怎么实现的 "},"history/2019-06-21.html":{"url":"history/2019-06-21.html","title":"2019-06-21","keywords":"","body":"2019年06月21日 关于写面试题问题 问题的难度并不重要:或许面试官需要的是一个态度,你求职的一个态度 如果求职连一个面试题都不愿意写,那么态度可想而知美住必成 在vue框架使用过程中遇到的印象比较深刻的问题bug 在微信小程序开发过程中遇到的印象比较深刻的问题bug 获得场景视频 css3动画 定义及使用 HTML5新增canvas 基本使用 js方面 如何注册事件 如何给循环渲染的dom元素注册事件 如何阻止冒泡 如何在事件冒泡阶段捕获状态 如何得到触发事件的元素 jq注册事件 jq注册事件委托 jq冒泡 array array常用的方法 node常用模块 webpack webpack与grunt、gulp的不同？ 几个常见的plugin 几个常见的loader vue vue-router常用api 传递参数的方式 哆啦宝 小程序方面 app.js 生命周期 页面跳转到tabBar页面如何携带参数 关于和APP混合开发 如何确保数据的安全性 如何接收APP传入的数据 es6 常用方法,及使用 java继承和es6继承的不同 模块化 组件化 css link 和 @import的区别 "}}